// p.234 Figure 11.5; Definition and rules for => (implies)
// A, B : *
def2    // (1) =>(A, B) := A -> B : *
2
A
*
B
*
implies
?a:(A).(B)
*
edef2

// | u : A -> B   ( equivalent to u : ?x:(A).(B) )
def2    // (2) =>-in(A, B, u) := u : A=>B
3
A
*
B
*
u
?y:(A).(B)
implies_in
u
implies[(A),(B)]
edef2

// | u : A -> B | v : A
def2    // (3) =>-el(A, B, u, v) := uv : B
4
A
*
B
*
u
?x:(A).(B)
v
A
implies_el
%(u)(v)
B
edef2

// p.235 Figure 11.6; Definition and rules for _|_ (bottom)
def2    // (1) contra := (?A : * . A) : *
0
contra
?A:(*).(A)
*
edef2

// A : *
// | u : A | v : A => contra
def2    // (2) contra_in(A, u, v) := vu : contra
3
A
*
u
A
v
implies[(A),(contra[])]
contra_in   // name
%(v)(u)
contra[]
edef2

// | u : contra
def2    // (3) contra_el(A, u) := uA : A
2
A
*
u
contra[]
contra_el
%(u)(A)
A
edef2

// p.235 Figure 11.7; Definition and rules for ￢(bar)
// A : *
def2    // (1) not(A) := A => contra : *
1
A
*
not
implies[(A),(contra[])]
*
edef2

// | u : A -> contra[]
def2    // (2) not_in(A, u) := u : not(A)
2
A
*
u
?x:(A).(contra[])
not_in
u
not[(A)]
edef2

// | u : not(A) | v : A
def2    // (3) not_el(A, u, v) := uv : contra[]
3
A
*
u
not[(A)]
v
A
not_el
%(u)(v)
contra[]
edef2

// p.235 Figure 11.8; Derivation of A => ￢￢A in natural deduction style
// A : * | u : A | v : not(A)
def2    // (1)
3
A
*
u
A
v
not[(A)]
a1_fig11-8     // name
not_el[(A),(v),(u)]
contra[]
edef2

// | |
def2    // (2)
2
A
*
u
A
a2_fig11-8     // name
not_in[(not[(A)]),($v:(not[(A)]).(a1_fig11-8[(A),(u),(v)]))]
not[(not[(A)])]
edef2

// |
def2    // (3)
1
A
*
a3_fig11-8     // name
implies_in[(A),(not[(not[(A)])]),($u:(A).(a2_fig11-8[(A),(u)]))]
implies[(A),(not[(not[(A)])])]
edef2


// p.236 Figure 11.9; Derivation of A => not[not[A]] in type-theoretic style
// A : *
// | u : A
def2    // (2)
2
A
*
u
A
a2_fig11-9
$v:(not[(A)]).(%(v)(u))
not[(not[(A)])]
edef2

// |
def2    // (3)
1
A
*
a3_fig11-9
$u:(A).(a2_fig11-9[(A), (u)])
implies[(A), (not[(not[(A)])])]
edef2

// p.236 Figure 11.10; Definition and rules for /\ (and)
// A, B : *
def2    // (1)
2
A
*
B
*
and
?C:(*).(implies[(implies[(A),(implies[(B),(C)])]),(C)])
*
edef2

// | u : A | v : B
def2    // (2)
4
A
*
B
*
u
A
v
B
and_in
$C:(*).($w:(implies[(A),(implies[(B),(C)])]).(%(%(w)(u))(v)))
and[(A),(B)]
edef2

// | u : and[A, B]
def2    // (3)
3
A
*
B
*
u
and[(A),(B)]
and_el1     // name
%(%(u)(A))($v:(A).($w:(B).(v)))
A
edef2

// | |
def2    // (4)
3
A
*
B
*
u
and[(A),(B)]
and_el2     // name
%(%(u)(B))($v:(A).($w:(B).(w)))
B
edef2

// p.237 Figure 11.11; Definition and rules for \/ (or)
// A, B: *
def2    // (1)
2
A
*
B
*
or
?C:(*).(implies[(implies[(A),(C)]),(implies[(implies[(B),(C)]),(C)])])
*
edef2

// | u:A
def2    // (2)
3
A
*
B
*
u
A
or_in1  // name
$C:(*).($v:(implies[(A),(C)]).($w:(implies[(B),(C)]).(%(v)(u))))
or[(A),(B)]
edef2

// | u:B
def2    // (3)
3
A
*
B
*
u
B
or_in2  // name
$C:(*).($v:(implies[(A),(C)]).($w:(implies[(B),(C)]).(%(w)(u))))
or[(A),(B)]
edef2

END
